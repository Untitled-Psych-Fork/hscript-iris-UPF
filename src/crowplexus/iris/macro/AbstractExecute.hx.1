package crowplexus.iris.macro;

#if macro
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type;

/**
 * 别看，我tm还没打算做
 */
class AbstractExecute {
	public static inline var ABSTRACT_IMPLEMENTS_STUFFIX: String = "_SEX_AIS";
	static var specifyAbstractPath: Null<String>;
	static var specifyAbstract: Ref<AbstractType>;

	public static function build(): Array<Field> {
		var fields: Array<Field> = [];
		final cls = Context.getLocalClass()?.get();
		var metas = cls.meta.get();
		if (metas != null) {
			final meta = Lambda.find(metas, m -> m.name == ":abstractAlias");
			if (meta == null)
				Context.error("Class: " + Context.getLocalClass() + " Not Found meta -> 'abstractAlias'", Context.currentPos());
			if (meta.params.length == 1) {
				switch (meta.params[0].expr) {
					case EConst(c):
						switch (c) {
							case CString(con):
								specifyAbstractPath = con;
								switch (Context.getType(specifyAbstractPath)) {
									case TAbstract(sb, params):
										specifyAbstract = sb;
									case _:
								}
							case _:
						}
					case _:
				}
			} else {
				Context.error("Class: " + Context.getLocalClass() + "meta -> abstractAlias requested params only 1.", Context.currentPos());
			}
		}
		if (specifyAbstract == null)
			Context.error("Invalid Abstract Alias -> '" + specifyAbstractPath + "'", Context.currentPos());
		trace(specifyAbstract.get().resolveWrite);
		return fields;
	}
}
#else
class AbstractExecute {
	public static inline var ABSTRACT_EXECUTE_STUFFIX: String = "_SEX_AIS";
}
#end
